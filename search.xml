<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[在线HTML页面导出pdf或图片,支持模拟跳过登陆验证]]></title>
    <url>%2F2019%2F09%2F10%2Fhello-world%20-%20%E5%89%AF%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[项目经常用到把当前页面导出为pdf，或者生成某个页面或部分的快照。如果是简单的页面快照，不没有太多的渲染，可以用html2canvas.min.js导出图片或者html2pdf.bundle.min.js导出为pdf，仅仅在前端就可以完成。但是复杂的页面，以上的导出效果不好，质量也不高。因此我采用PhantomJS，用后台生成pdf、png等进行导出。 1.PhantomJS简介 PhantomJS是一个基于webkit的JavaScript API。它使用QtWebKit作为它核心浏览器的功能，使用webkit来编译解释执行JavaScript代码。任何你可以在基于webkit浏览器做的事情，它都能做到。它不仅是个隐形的浏览器，提供了诸如CSS选择器、支持Web标准、DOM操作、JSON、HTML5、Canvas、SVG等，同时也提供了处理文件I/O的操作，从而使你可以向操作系统读写文件等。PhantomJS的用处可谓非常广泛，诸如网络监测、网页截屏、无需浏览器的 Web 测试、页面访问自动化等。 2.下载及安装官方下载地址：http://phantomjs.org/download.html。目前官方支持三种操作系统，包括windows\Mac OS\Linux这三大主流的环境。根据运行环境选择要下载的包，下面以Windows7为例，我将phantomjs文件放置到D盘根目录下，里面的内容如下图。 3.如何使用1) 准备一个配置的js文件在D盘phantomjs目录下新建一个html2pdf.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778/** * phantomJs 脚本 html转图片 */var page = require('webpage').create(), system = require('system'), address, output, size,JSESSIONID,domain;if (system.args.length &lt; 3 || system.args.length &gt; 5) &#123; phantom.exit(1);&#125; else &#123; address = system.args[1]; output = system.args[2]; if(system.args.length&gt;3)&#123; JSESSIONID = system.args[3]; domain = system.args[4]; // 添加cookie phantom.addCookie(&#123; "name":"JSESSIONID", "value":JSESSIONID, "domain":domain, "path":"/", "httponly":false, "secure":false, "expires": "Fri, 01 Jan 2038 00:00:00 GMT" &#125;); &#125; //定义浏览器宽高 page.viewportSize = &#123; width : 2048, height : 768 &#125;; // 纸张尺寸 page.paperSize = &#123; format: 'A3', orientation: 'landscape',//横向 margin: &#123; left:"2cm", right:"2cm", top:"1cm", bottom:"1cm" &#125; &#125;; page.open(address, function(status) &#123; console.log('Status: ' + status); if (status !== 'success') &#123; console.log('Unable to load the address!'); phantom.exit(1); &#125; else &#123; var bb = page.evaluate(function() &#123; //var child=document.getElementById("printBt"); //child.parentNode.removeChild(child);//此外可以写一些对页面操作的代码，比如词句代码是删除页面上的打印按钮 return document.getElementsByTagName('html')[0].getBoundingClientRect();//返回内容就是要导出的范围（此处是HTML整页） &#125;); // 截取范围 page.clipRect = &#123; top : bb.top, left : bb.left, width : bb.width, height : bb.height &#125;; // 等待页面渲染 window.setTimeout(function() &#123; page.render(output, &#123;format: 'pdf', quality: '100'&#125;);//这里配置导出的格式pdf,png等，quality为导出质量 page.close(); console.log('渲染成功...'); phantom.exit(); &#125;, 2000); &#125; &#125;);&#125;address = system.args[1];//传入的URL地址output = system.args[2];//保存的图片路径 2）测试命令 例如：phantomjs文件夹放于D盘根目录，在phantomjs/bin 目录下（也可以配置环境变量）打开控制台。以我的CSDN博客页面https://blog.csdn.net/xiweiller导出为PDF为例。输入如下命令: 1phantomjs.exe D:/phantomjs/html2pdf.js https://blog.csdn.net/xiweiller D:/phantomjs/blog.pdf 其中 phantomjs.exe是执行命令文件， D:/phantomjs/screenshot.js是执行的配置js文件，https://blog.csdn.net/xiweiller是目标HTML，D:/phantomjs/blog.pdf是导出PDF的路径。 3） java中的使用，springboot项目为例 application.yml中添加配置，配置项为phantomjs执行文件路径 12345htmltopdf: path: windows: D:/phantomjs/bin/phantomjs.exe linux: /root/soft/phantomjs-2.1.1-linux-x86_64/bin/phantomjs mac: Html转Pdf工具类 参数： - htmlPath 目标网页访问地址 - pdfPath 导出pdf存放目录 - JSESSIONID 登陆认证时需要传递，用于cookie携带 - domain cookie中获取 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283/** * Html转Pdf工具类 * */@Componentpublic class HtmlToPdf &#123; @Value("$&#123;htmltopdf.path.windows&#125;") private String WINDOWS_WKHTMLTOPDF_PATH; @Value("$&#123;htmltopdf.path.mac&#125;") private String MAC_WKHTMLTOPDF_PATH; @Value("$&#123;htmltopdf.path.linux&#125;") private String LINUX_WKHTMLTOPDF_PATH; private static Logger log = LoggerFactory.getLogger(HtmlToPdf.class); /** * html转pdf核心方法 * @param htmlPath html路径（硬盘和网盘路径都支持） * @param pdfPath pdf存储路径 * @return 转换成功：true，失败：false */ public boolean convert(String htmlPath, String pdfPath,String JSESSIONID,String domain) &#123; File file = new File(pdfPath); File parent = file.getParentFile(); if (!parent.exists()) &#123;// 如果pdf保存路径不存在，则创建路径 parent.mkdirs(); &#125; String toolDir = null;// 转换工具在系统中的路径 if (System.getProperty("os.name").indexOf("Windows") != -1) &#123;//windows 系统 toolDir = WINDOWS_WKHTMLTOPDF_PATH; &#125;else if(System.getProperty("os.name").indexOf("Mac OS X") != -1)&#123;//mac 系统 toolDir = MAC_WKHTMLTOPDF_PATH; &#125;else if(System.getProperty("os.name").indexOf("Linux") != -1)&#123;//linux 系统 toolDir = LINUX_WKHTMLTOPDF_PATH; &#125; boolean result = true;//pdf创建成功标识，默认成功 String BLANK = " ";//空格 Process process = null;//图片输出路径 StringBuffer sbf = null; InputStream is = null; StringBuilder cmd = new StringBuilder(); cmd.append(toolDir) .append(BLANK) .append(new File(toolDir).getParent()).append(File.separator).append("html2pdf.js") .append(BLANK) .append(htmlPath) .append(BLANK) .append(pdfPath); if(JSESSIONID!=null)&#123;//添加cookie值 cmd.append(BLANK).append(JSESSIONID); cmd.append(BLANK).append(domain); &#125; try &#123; log.info("报表准备导出 " ); log.info("导出命令：&#123;&#125;",cmd.toString() ); process = Runtime.getRuntime().exec(cmd.toString());// 输出路径 is = process.getInputStream(); BufferedReader br = new BufferedReader(new InputStreamReader(is)); sbf = new StringBuffer(); String tmp = ""; while ((tmp = br.readLine()) != null) &#123; sbf.append(tmp); &#125; log.info("报表导出完成 " ); &#125; catch (IOException e) &#123; result = false; log.error("报表导出失败！", e); &#125; finally &#123; if (is != null) &#123; try &#123; is.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; is = null; &#125; &#125; return result; &#125;&#125; 转换工具的调用 123456789101112131415public void test( HttpServletRequest request )&#123; // 注意不同部署环境，路径不同。 String htmlUrl = "D:/phantomjs/html2pdf.js"; String pdfPath = "D:/phantomjs/export.pdf" String JSESSIONID = ""; String domain = request.getServerName(); Cookie[] cookies = request.getCookies(); for(Cookie cookie :cookies)&#123; if("JSESSIONID".equals(cookie.getName()))&#123; JSESSIONID = cookie.getValue(); &#125; &#125; //将html转换为pdf文件 boolean isno =htmlToPdf.convert(htmlUrl,pdfPath,JSESSIONID,domain); &#125; 4. 注意事项​ 在实际项目使用时，我们必须保证页面异步加载的速度比较快，否则会出现页面渲染不完整的问题。因此在项目中，被导出的目标页面最好能做到快速响应，尽量减少异步请求加载，或者保证异步接口快速响应。]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[在线HTML页面导出pdf或图片,支持模拟跳过登陆验证]]></title>
    <url>%2F2019%2F09%2F10%2F%E5%9C%A8%E7%BA%BFHTML%E9%A1%B5%E9%9D%A2%E5%AF%BC%E5%87%BApdf%E6%88%96%E5%9B%BE%E7%89%87%2C%E6%94%AF%E6%8C%81%E6%A8%A1%E6%8B%9F%E8%B7%B3%E8%BF%87%E7%99%BB%E9%99%86%E9%AA%8C%E8%AF%81%2F</url>
    <content type="text"><![CDATA[项目经常用到把当前页面导出为pdf，或者生成某个页面或部分的快照。如果是简单的页面快照，不没有太多的渲染，可以用html2canvas.min.js导出图片或者html2pdf.bundle.min.js导出为pdf，仅仅在前端就可以完成。但是复杂的页面，以上的导出效果不好，质量也不高。因此我采用PhantomJS，用后台生成pdf、png等进行导出。 1.PhantomJS简介 PhantomJS是一个基于webkit的JavaScript API。它使用QtWebKit作为它核心浏览器的功能，使用webkit来编译解释执行JavaScript代码。任何你可以在基于webkit浏览器做的事情，它都能做到。它不仅是个隐形的浏览器，提供了诸如CSS选择器、支持Web标准、DOM操作、JSON、HTML5、Canvas、SVG等，同时也提供了处理文件I/O的操作，从而使你可以向操作系统读写文件等。PhantomJS的用处可谓非常广泛，诸如网络监测、网页截屏、无需浏览器的 Web 测试、页面访问自动化等。 2.下载及安装官方下载地址：http://phantomjs.org/download.html。目前官方支持三种操作系统，包括windows\Mac OS\Linux这三大主流的环境。根据运行环境选择要下载的包，下面以Windows7为例，我将phantomjs文件放置到D盘根目录下，里面的内容如下图。 3.如何使用1) 准备一个配置的js文件在D盘phantomjs目录下新建一个html2pdf.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778/** * phantomJs 脚本 html转图片 */var page = require('webpage').create(), system = require('system'), address, output, size,JSESSIONID,domain;if (system.args.length &lt; 3 || system.args.length &gt; 5) &#123; phantom.exit(1);&#125; else &#123; address = system.args[1]; output = system.args[2]; if(system.args.length&gt;3)&#123; JSESSIONID = system.args[3]; domain = system.args[4]; // 添加cookie phantom.addCookie(&#123; "name":"JSESSIONID", "value":JSESSIONID, "domain":domain, "path":"/", "httponly":false, "secure":false, "expires": "Fri, 01 Jan 2038 00:00:00 GMT" &#125;); &#125; //定义浏览器宽高 page.viewportSize = &#123; width : 2048, height : 768 &#125;; // 纸张尺寸 page.paperSize = &#123; format: 'A3', orientation: 'landscape',//横向 margin: &#123; left:"2cm", right:"2cm", top:"1cm", bottom:"1cm" &#125; &#125;; page.open(address, function(status) &#123; console.log('Status: ' + status); if (status !== 'success') &#123; console.log('Unable to load the address!'); phantom.exit(1); &#125; else &#123; var bb = page.evaluate(function() &#123; //var child=document.getElementById("printBt"); //child.parentNode.removeChild(child);//此外可以写一些对页面操作的代码，比如词句代码是删除页面上的打印按钮 return document.getElementsByTagName('html')[0].getBoundingClientRect();//返回内容就是要导出的范围（此处是HTML整页） &#125;); // 截取范围 page.clipRect = &#123; top : bb.top, left : bb.left, width : bb.width, height : bb.height &#125;; // 等待页面渲染 window.setTimeout(function() &#123; page.render(output, &#123;format: 'pdf', quality: '100'&#125;);//这里配置导出的格式pdf,png等，quality为导出质量 page.close(); console.log('渲染成功...'); phantom.exit(); &#125;, 2000); &#125; &#125;);&#125;address = system.args[1];//传入的URL地址output = system.args[2];//保存的图片路径 2）测试命令 例如：phantomjs文件夹放于D盘根目录，在phantomjs/bin 目录下（也可以配置环境变量）打开控制台。以我的CSDN博客页面https://blog.csdn.net/xiweiller导出为PDF为例。输入如下命令: 1phantomjs.exe D:/phantomjs/html2pdf.js https://blog.csdn.net/xiweiller D:/phantomjs/blog.pdf 其中 phantomjs.exe是执行命令文件， D:/phantomjs/screenshot.js是执行的配置js文件，https://blog.csdn.net/xiweiller是目标HTML，D:/phantomjs/blog.pdf是导出PDF的路径。 3） java中的使用，springboot项目为例 application.yml中添加配置，配置项为phantomjs执行文件路径 12345htmltopdf: path: windows: D:/phantomjs/bin/phantomjs.exe linux: /root/soft/phantomjs-2.1.1-linux-x86_64/bin/phantomjs mac: Html转Pdf工具类 参数： - htmlPath 目标网页访问地址 - pdfPath 导出pdf存放目录 - JSESSIONID 登陆认证时需要传递，用于cookie携带 - domain cookie中获取 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283/** * Html转Pdf工具类 * */@Componentpublic class HtmlToPdf &#123; @Value("$&#123;htmltopdf.path.windows&#125;") private String WINDOWS_WKHTMLTOPDF_PATH; @Value("$&#123;htmltopdf.path.mac&#125;") private String MAC_WKHTMLTOPDF_PATH; @Value("$&#123;htmltopdf.path.linux&#125;") private String LINUX_WKHTMLTOPDF_PATH; private static Logger log = LoggerFactory.getLogger(HtmlToPdf.class); /** * html转pdf核心方法 * @param htmlPath html路径（硬盘和网盘路径都支持） * @param pdfPath pdf存储路径 * @return 转换成功：true，失败：false */ public boolean convert(String htmlPath, String pdfPath,String JSESSIONID,String domain) &#123; File file = new File(pdfPath); File parent = file.getParentFile(); if (!parent.exists()) &#123;// 如果pdf保存路径不存在，则创建路径 parent.mkdirs(); &#125; String toolDir = null;// 转换工具在系统中的路径 if (System.getProperty("os.name").indexOf("Windows") != -1) &#123;//windows 系统 toolDir = WINDOWS_WKHTMLTOPDF_PATH; &#125;else if(System.getProperty("os.name").indexOf("Mac OS X") != -1)&#123;//mac 系统 toolDir = MAC_WKHTMLTOPDF_PATH; &#125;else if(System.getProperty("os.name").indexOf("Linux") != -1)&#123;//linux 系统 toolDir = LINUX_WKHTMLTOPDF_PATH; &#125; boolean result = true;//pdf创建成功标识，默认成功 String BLANK = " ";//空格 Process process = null;//图片输出路径 StringBuffer sbf = null; InputStream is = null; StringBuilder cmd = new StringBuilder(); cmd.append(toolDir) .append(BLANK) .append(new File(toolDir).getParent()).append(File.separator).append("html2pdf.js") .append(BLANK) .append(htmlPath) .append(BLANK) .append(pdfPath); if(JSESSIONID!=null)&#123;//添加cookie值 cmd.append(BLANK).append(JSESSIONID); cmd.append(BLANK).append(domain); &#125; try &#123; log.info("报表准备导出 " ); log.info("导出命令：&#123;&#125;",cmd.toString() ); process = Runtime.getRuntime().exec(cmd.toString());// 输出路径 is = process.getInputStream(); BufferedReader br = new BufferedReader(new InputStreamReader(is)); sbf = new StringBuffer(); String tmp = ""; while ((tmp = br.readLine()) != null) &#123; sbf.append(tmp); &#125; log.info("报表导出完成 " ); &#125; catch (IOException e) &#123; result = false; log.error("报表导出失败！", e); &#125; finally &#123; if (is != null) &#123; try &#123; is.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; is = null; &#125; &#125; return result; &#125;&#125; 转换工具的调用 123456789101112131415public void test( HttpServletRequest request )&#123; // 注意不同部署环境，路径不同。 String htmlUrl = "D:/phantomjs/html2pdf.js"; String pdfPath = "D:/phantomjs/export.pdf" String JSESSIONID = ""; String domain = request.getServerName(); Cookie[] cookies = request.getCookies(); for(Cookie cookie :cookies)&#123; if("JSESSIONID".equals(cookie.getName()))&#123; JSESSIONID = cookie.getValue(); &#125; &#125; //将html转换为pdf文件 boolean isno =htmlToPdf.convert(htmlUrl,pdfPath,JSESSIONID,domain); &#125; 4. 注意事项​ 在实际项目使用时，我们必须保证页面异步加载的速度比较快，否则会出现页面渲染不完整的问题。因此在项目中，被导出的目标页面最好能做到快速响应，尽量减少异步请求加载，或者保证异步接口快速响应。]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[简单的HTML快照生成,导出pdf或图片]]></title>
    <url>%2F2019%2F09%2F01%2F%E7%AE%80%E5%8D%95%E7%9A%84HTML%E5%BF%AB%E7%85%A7%E7%94%9F%E6%88%90%2C%E5%AF%BC%E5%87%BApdf%E6%88%96%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[一、利用 html2canvas实现HTML页面截图 官方网址： https://html2canvas.hertzen.com/ GitHub：https://github.com/niklasvh/html2canvas 1.HTML页面引入 html2canvas.min.js2.定义一个截图的触发按钮1234&lt;button onclick="exprotImg();"&gt;导出图片&lt;/button&gt; &lt;a href="" download="canvas.png" id="save_href" style="display:none"&gt; &lt;img src="" id="save_img"/&gt; &lt;/a&gt; 3.js代码12345678910111213141516171819202122232425function exprotImg() &#123; // 要截图的元素 var element = document.getElementsByTagName('html')[0]; // 获取元素的大小及其相对于视口的位置等参数 var dd= element.getBoundingClientRect(); var opts = &#123; scale: 2, // 添加的scale 参数 // logging: true, //日志开关，便于查看html2canvas的内部执行流程 width: dd.width, //dom 原始宽度 height: dd.height, useCORS: true, // 【重要】开启跨域配置 allowTaint:true &#125;; html2canvas(element,opts).then(function(canvas) &#123; // 模拟的下载按钮 var svaeHref = document.getElementById("save_href"); var img = document.getElementById("save_img"); var tempSrc = canvas.toDataURL("image/png"); svaeHref.href=tempSrc; img.src=tempSrc; $(img).click(); &#125;);&#125; 二、利用 html2pdf 实现页面导出pdf GitHub ：https://github.com/eKoopmans/html2pdf 1.页面导入 html2pdf.bundle.min.js2.导出按钮1&lt;button onclick="exprotPdf();"&gt;导出pdf&lt;/button&gt; 3.js代码123456789101112131415161718192021function exprotPdf() &#123; // 要截图的元素 var element = document.getElementsByTagName('html')[0]; // 获取元素的大小及其相对于视口的位置等参数 var opt = &#123; margin: 1, filename: 'myfile.pdf', image: &#123; type: 'png', quality: 0.98 &#125;, html2canvas: &#123; scale: 2, useCORS:true, // 【重要】开启跨域配置 allowTaint:true, width:dd.width, height:dd.height &#125;, jsPDF: &#123; unit: 'in', format: 'letter', orientation: 'portrait' &#125; &#125;; html2pdf().from(element).set(opt).save();&#125;]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[在线sql编辑查询工具sql-editor]]></title>
    <url>%2F2019%2F07%2F19%2Fsql-editor%2F</url>
    <content type="text"><![CDATA[sql-editor是基于CodeMirror的一个在线sql编辑工具，模仿navicat工具，开发的一个简易版。 目前只提供前端代码，由easy-mock提供json测试数据。 Github地址: https://github.com/xiweile/sql-editor 功能更新 左侧提供数据库表字段树形结构，可拖拽到sql编辑框。(2019-7-19新增) 编辑区和数据展示区上下拖动更改大小。(2019-7-19新增) 执行与中断功能。(2019-7-19新增) 自定义外部接口获取sql关键词、函数、表字段等，用于sql编辑时提示补全,键盘录入后自动提示，上下键选择，tab键或点击选中项自动补全。(2019-7-16) sql格式化。(2019-7-16) 一些截图：]]></content>
      <categories>
        <category>前端</category>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[一个基于jquery的仿vue的简易js模板]]></title>
    <url>%2F2019%2F06%2F26%2Fwuedemo%2F</url>
    <content type="text"><![CDATA[现在的项目大部分都是前后端分离的模式，作为后端开发者，喜欢用一些成熟的前端框架（如：layui）方便开发，尤其在前端工程师紧缺的情况下，后端开发者可以容易入手，后来又引入了vue.js使原有的HTML数据渲染和js动态操作更加快捷。但是在一次政府项目中，要求浏览器支持到ie8，这样vue支持的不好，因此将原来的vue写法改成原始jquery写法，为了改动最小化，便写了一个简单js，用于支持模板替换、el表达式解析等功能，我将名字命名为wue.js 1. 支持的模板 v-text 标签内文本替换 v-value 标签中value值替换 v-each 标签内部节点遍历 i-value v-each使用标签中循环子节点中使用，替换内部子节点value值 i-text v-each使用循环子节点中使用，替换内部子节点内文本值 i-click v-each使用循环子节点中使用，为内部子节点添加点击事件 e-click 标签添加点击事件 2. HTML中模板的使用 页面引入jquery.min.js和wue.js 查看文件wue.js 定义一个wue实例，js标签写在HTML中的body内最底部。 1234567891011121314151617181920212223242526var vm_app = new Wue(&#123; el:"#app", data:&#123; title:"一个案例", user:&#123; name:"张三", age:25 &#125;, menu:[ &#123;"id":"bh1","name":"目录1"&#125;, &#123;"id":"bh2","name":"目录2"&#125;, &#123;"id":"bh3","name":"目录3"&#125;, ], &#125;, methods:&#123; init:function()&#123; this.replaceModel(); &#125;, show:function(p)&#123; alert(this.title+"--"+p) &#125; &#125;&#125;);vm_app.init(); 参数说明： el dom选择器，限定模板的解析范围 data 数据定义 methods 方法定义 init 页面加载完成后的执行入口方法 页面定义模板 模板均使用在HTML标签的属性中，模板名作为属性名，值中使用双大括号作为解析对象 v-text、v-value写法一样，例如v-text=&quot;姓名-&quot; ,双大括号中的内容，会使用wue实例中data内的值进行解析并替换，双大括号外的内容不解析。 e-click定义在属性中，为该标签添加点击事件，事件的函数可以使用多个参数，参数之间用,分隔，可以是变量取值，也可以是其他常量，例如e-click=&quot;show(user.name)&quot;，e-click=&quot;show(&#39;这是点击事件&#39;)&quot;，e-click=&quot;sayUser(&#39;姓名&#39;,user.name,user.id)&quot;。 v-each写在循环体元素的父标签上，写法为v-each=&quot;m,item in menu&quot;或v-each=&quot;m in menu&quot;，字母in 前后分别为遍历的变量名、被遍历的数据集合，与in分别严格用一个空格隔开，变量名部分可以用，分隔，左侧为数据变量名，右侧为元数据对象，里面包含：索引值index，序号：num，总行数count。 内部循环体元素定义时，需要添加隐藏属性style=&quot;display:none&quot;，用于循环的 参照模板，它的属性中使用i-text、i-value进行文本和value属性赋值，取值对象则为自定义的循环变量或元数据变量，例如i-text=&quot;&quot;，i-text=&quot;&quot;，如果添加点击事件则使用i-click，例如i-click=&quot;show(m.id)&quot;，i-click=&quot;show(&#39;我是循环元素的点击事件&#39;)&quot;，事件的函数定义方式和e-click相同。 双括号内表达式支持自定义的函数。函数可以定义在当前wue实例methods中，也可以定义在页面全局window域下。书写方式如：myfun(user.name) 使用wue的实例名，调用init()方法进行初始化，init方法内部为页面加载完成后要执行的逻辑，this.replaceModel()调用时执行模板解析和替换逻辑，replaceModel()方法可以携带一个参数，参数为dom选择器，如replaceModel(&#39;#table&#39;)，注意该选择器必须在el内部，表示仅解析或替换指定范围的模板。调用该方法根据逻辑需要，放于数据返回并已赋值给wue实例之后，赋值方法如this.resultdata = r.data。 3. 完整案例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;el解析案例&lt;/title&gt; &lt;!-- 引入jQuery --&gt; &lt;script src="js/jquery.min.js"&gt;&lt;/script&gt; &lt;!-- 引入自定义的wue.js --&gt; &lt;script src="js/wue.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body &gt; &lt;div id="app"&gt; &lt;div&gt; v-text属性：&lt;span v-text="这是标题：&#123;&#123;title&#125;&#125;"&gt;这是标题：&lt;/span&gt; &lt;/div&gt; &lt;div&gt; v-value属性:&lt;input type="text" v-value="&#123;&#123;user.name&#125;&#125;"&gt;&lt;/input&gt; &lt;/div&gt; &lt;div&gt; e-click属性:&lt;button e-click="show('点击事件')"&gt;点击按钮&lt;/button&gt; &lt;/div&gt; &lt;div&gt; v-each:属性 &lt;ul v-each="m,item in menu"&gt; &lt;li style="display:none" &gt; &lt;span i-text="&#123;&#123;item.num&#125;&#125;"&gt;&lt;/span&gt; &lt;a href="javascript:;" i-click="show(m.id)" i-text="&#123;&#123;m.name&#125;&#125;"&gt;&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; var vm_app = new Wue(&#123; el:"#app", data:&#123; title:"一个案例", user:&#123; name:"张三", age:25 &#125;, menu:[ &#123;"id":"bh1","name":"目录1"&#125;, &#123;"id":"bh2","name":"目录2"&#125;, &#123;"id":"bh3","name":"目录3"&#125;, ], &#125;, methods:&#123; init:function()&#123; this.replaceModel(); &#125;, show:function(p)&#123; alert(this.title+"--"+p) &#125; &#125; &#125;); vm_app.init(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 页面效果：]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[从这里开始]]></title>
    <url>%2F2019%2F03%2F14%2Fhello-world%2F</url>
    <content type="text"><![CDATA[我的个人博客搭建好了，先简单尝试发表一篇吧，在后续有空时间里，我将写一些JAVA学习总结，以及自己平时生活爱好随笔，欢迎大家随时访问，记住我的博客域名 www.weiller.cn 。下面分享一篇美文。 轻轻晃动手中地茶杯，看淡绿色地茶或针或片，忽上忽下，簇拥着，沉沉浮浮，变换着不同地位置，试图寻找-个属于自己地最佳平衡点。心急地我常常等不得茶泡好，就轻吹杯口，带动-漾-漾地茶涡，看茶叶聚聚散散，无奈分离。呷-小口茶，任清清浅浅地苦涩在舌间荡漾开来，充溢齿喉。之后，深吸-口气，余香满唇，在肺腑间蔓延开来，涤尽了-切地疲惫冷漠。人仿佛也醉了，朦胧中，久久不愿醒来。 是夜，茶香满室，杯中茶由淡变浓，浮浮沉沉，聚聚散散，苦涩清香中慢慢感悟：人生亦如茶。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
</search>
